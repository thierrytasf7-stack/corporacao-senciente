# Backup-DockerData.ps1
# Data Preservation and Backup System
# Extracts Docker volume data and configuration files with checksum verification
# Creates backup manifest JSON with checksums and metadata

<#
.SYNOPSIS
    Preserves Docker container data and configurations before migration.

.DESCRIPTION
    Extracts all Docker volume data, configuration files, and container metadata
    with checksum generation for integrity verification. Creates a comprehensive
    backup manifest in JSON format for migration tracking and rollback capability.

.PARAMETER InventoryPath
    Path to the inventory JSON file generated by Get-DockerInventory.ps1
    Default: C:\project\migration\inventory.json

.PARAMETER BackupRoot
    Root directory where backups will be stored.
    Default: C:\project\migration\backups

.PARAMETER VerifyChecksums
    Verify checksums after backup to ensure data integrity.
    Default: $true

.EXAMPLE
    .\Backup-DockerData.ps1
    Backs up all containers from default inventory location.

.EXAMPLE
    .\Backup-DockerData.ps1 -InventoryPath "C:\custom\inventory.json" -BackupRoot "D:\backups"
    Backs up containers using custom paths.

.NOTES
    Validates: Requirements 1.3, 11.1, 11.2
    Part of: Sentient Corp Native Architecture Migration
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [string]$InventoryPath = "C:\project\migration\inventory.json",
    
    [Parameter(Mandatory=$false)]
    [string]$BackupRoot = "C:\project\migration\backups",
    
    [Parameter(Mandatory=$false)]
    [bool]$VerifyChecksums = $true
)

$ErrorActionPreference = "Stop"

# Initialize backup manifest
$manifest = @{
    backup_started_at = Get-Date -Format "o"
    backup_completed_at = $null
    backup_root = $BackupRoot
    inventory_source = $InventoryPath
    containers = @()
    summary = @{
        total_containers = 0
        successful_backups = 0
        failed_backups = 0
        total_volumes_backed_up = 0
        total_configs_backed_up = 0
        total_size_bytes = 0
    }
    verification = @{
        checksums_verified = $false
        verification_passed = $false
        failed_verifications = @()
    }
}

function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    Write-Host "[$timestamp] [$Level] $Message"
}

function Get-FileChecksum {
    param(
        [Parameter(Mandatory=$true)]
        [string]$FilePath,
        [string]$Algorithm = "SHA256"
    )
    
    try {
        if (-not (Test-Path $FilePath)) {
            Write-Log "File not found for checksum: $FilePath" "WARNING"
            return $null
        }
        
        $hash = Get-FileHash -Path $FilePath -Algorithm $Algorithm
        return $hash.Hash
    }
    catch {
        Write-Log "Failed to calculate checksum for $FilePath : $_" "ERROR"
        return $null
    }
}

function Get-DirectoryChecksum {
    param(
        [Parameter(Mandatory=$true)]
        [string]$DirectoryPath,
        [string]$Algorithm = "SHA256"
    )
    
    try {
        if (-not (Test-Path $DirectoryPath)) {
            Write-Log "Directory not found for checksum: $DirectoryPath" "WARNING"
            return $null
        }
        
        # Get all files recursively and calculate combined checksum
        $files = Get-ChildItem -Path $DirectoryPath -File -Recurse | Sort-Object FullName
        
        if ($files.Count -eq 0) {
            Write-Log "No files found in directory: $DirectoryPath" "WARNING"
            return "EMPTY_DIRECTORY"
        }
        
        $combinedHash = ""
        foreach ($file in $files) {
            $fileHash = Get-FileChecksum -FilePath $file.FullName -Algorithm $Algorithm
            if ($fileHash) {
                $combinedHash += $fileHash
            }
        }
        
        # Calculate hash of combined hashes
        $stream = [System.IO.MemoryStream]::new([System.Text.Encoding]::UTF8.GetBytes($combinedHash))
        $hashAlgo = [System.Security.Cryptography.HashAlgorithm]::Create($Algorithm)
        $finalHash = $hashAlgo.ComputeHash($stream)
        $stream.Close()
        
        return [System.BitConverter]::ToString($finalHash) -replace '-', ''
    }
    catch {
        Write-Log "Failed to calculate directory checksum for $DirectoryPath : $_" "ERROR"
        return $null
    }
}

function Backup-ContainerVolume {
    param(
        [Parameter(Mandatory=$true)]
        [string]$ContainerId,
        [Parameter(Mandatory=$true)]
        [hashtable]$VolumeInfo,
        [Parameter(Mandatory=$true)]
        [string]$BackupPath
    )
    
    try {
        Write-Log "Backing up volume: $($VolumeInfo.destination)" "INFO"
        
        $volumeBackup = @{
            source = $VolumeInfo.source
            destination = $VolumeInfo.destination
            type = $VolumeInfo.type
            backup_path = $BackupPath
            checksum = $null
            size_bytes = 0
            file_count = 0
            backed_up_at = Get-Date -Format "o"
            success = $false
            error = $null
        }
        
        # Create backup directory
        if (-not (Test-Path $BackupPath)) {
            New-Item -ItemType Directory -Path $BackupPath -Force | Out-Null
        }
        
        # For bind mounts, copy from host path
        if ($VolumeInfo.type -eq "bind") {
            if (Test-Path $VolumeInfo.source) {
                Write-Log "Copying bind mount from: $($VolumeInfo.source)" "INFO"
                Copy-Item -Path "$($VolumeInfo.source)\*" -Destination $BackupPath -Recurse -Force
                
                # Calculate size and file count
                $files = Get-ChildItem -Path $BackupPath -File -Recurse
                $volumeBackup.file_count = $files.Count
                $volumeBackup.size_bytes = ($files | Measure-Object -Property Length -Sum).Sum
            }
            else {
                Write-Log "Bind mount source not found: $($VolumeInfo.source)" "WARNING"
                $volumeBackup.error = "Source path not found"
            }
        }
        # For named volumes, use docker cp
        elseif ($VolumeInfo.type -eq "volume") {
            Write-Log "Extracting volume data using docker cp..." "INFO"
            
            # Use docker cp to extract volume data
            $dockerCpCmd = "docker cp ${ContainerId}:$($VolumeInfo.destination) $BackupPath"
            $result = Invoke-Expression $dockerCpCmd 2>&1
            
            if ($LASTEXITCODE -eq 0) {
                # Calculate size and file count
                $files = Get-ChildItem -Path $BackupPath -File -Recurse
                $volumeBackup.file_count = $files.Count
                $volumeBackup.size_bytes = ($files | Measure-Object -Property Length -Sum).Sum
            }
            else {
                Write-Log "Failed to extract volume: $result" "ERROR"
                $volumeBackup.error = "Docker cp failed: $result"
            }
        }
        
        # Calculate checksum if backup succeeded
        if ($volumeBackup.error -eq $null) {
            Write-Log "Calculating checksum for volume backup..." "INFO"
            $volumeBackup.checksum = Get-DirectoryChecksum -DirectoryPath $BackupPath
            $volumeBackup.success = $true
        }
        
        return $volumeBackup
    }
    catch {
        Write-Log "Error backing up volume: $_" "ERROR"
        return @{
            source = $VolumeInfo.source
            destination = $VolumeInfo.destination
            type = $VolumeInfo.type
            backup_path = $BackupPath
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Backup-ContainerConfig {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ContainerMetadata,
        [Parameter(Mandatory=$true)]
        [string]$BackupPath
    )
    
    try {
        Write-Log "Backing up configuration for container: $($ContainerMetadata.name)" "INFO"
        
        $configBackup = @{
            backup_path = $BackupPath
            checksum = $null
            backed_up_at = Get-Date -Format "o"
            success = $false
            error = $null
        }
        
        # Create backup directory
        if (-not (Test-Path $BackupPath)) {
            New-Item -ItemType Directory -Path $BackupPath -Force | Out-Null
        }
        
        # Save container metadata as JSON
        $metadataPath = Join-Path $BackupPath "container-metadata.json"
        $ContainerMetadata | ConvertTo-Json -Depth 10 | Out-File -FilePath $metadataPath -Encoding UTF8
        
        # Save environment variables
        $envPath = Join-Path $BackupPath "environment.json"
        @{ environment = $ContainerMetadata.config.env } | ConvertTo-Json -Depth 5 | Out-File -FilePath $envPath -Encoding UTF8
        
        # Save network configuration
        $networkPath = Join-Path $BackupPath "networks.json"
        @{ networks = $ContainerMetadata.networks } | ConvertTo-Json -Depth 5 | Out-File -FilePath $networkPath -Encoding UTF8
        
        # Save port bindings
        $portsPath = Join-Path $BackupPath "ports.json"
        @{ 
            exposed_ports = $ContainerMetadata.config.exposed_ports
            port_bindings = $ContainerMetadata.port_bindings
        } | ConvertTo-Json -Depth 5 | Out-File -FilePath $portsPath -Encoding UTF8
        
        # Save resource limits
        $resourcesPath = Join-Path $BackupPath "resources.json"
        @{ resources = $ContainerMetadata.resources } | ConvertTo-Json -Depth 5 | Out-File -FilePath $resourcesPath -Encoding UTF8
        
        # Calculate checksum for config directory
        Write-Log "Calculating checksum for configuration backup..." "INFO"
        $configBackup.checksum = Get-DirectoryChecksum -DirectoryPath $BackupPath
        $configBackup.success = $true
        
        return $configBackup
    }
    catch {
        Write-Log "Error backing up configuration: $_" "ERROR"
        return @{
            backup_path = $BackupPath
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Backup-Container {
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$ContainerMetadata
    )
    
    try {
        Write-Log "Starting backup for container: $($ContainerMetadata.name)" "INFO"
        
        $containerBackup = @{
            container_id = $ContainerMetadata.id
            container_name = $ContainerMetadata.name
            image = $ContainerMetadata.image
            backup_started_at = Get-Date -Format "o"
            backup_completed_at = $null
            volumes = @()
            config = $null
            success = $false
            error = $null
        }
        
        # Create container-specific backup directory
        $containerBackupRoot = Join-Path $BackupRoot $ContainerMetadata.name
        if (-not (Test-Path $containerBackupRoot)) {
            New-Item -ItemType Directory -Path $containerBackupRoot -Force | Out-Null
        }
        
        # Backup configuration
        $configBackupPath = Join-Path $containerBackupRoot "config"
        $containerBackup.config = Backup-ContainerConfig -ContainerMetadata $ContainerMetadata -BackupPath $configBackupPath
        
        if (-not $containerBackup.config.success) {
            Write-Log "Configuration backup failed for $($ContainerMetadata.name)" "ERROR"
            $containerBackup.error = "Configuration backup failed"
        }
        
        # Backup volumes
        $volumeIndex = 0
        foreach ($volume in $ContainerMetadata.volumes) {
            $volumeBackupPath = Join-Path $containerBackupRoot "volumes\volume-$volumeIndex"
            $volumeBackup = Backup-ContainerVolume -ContainerId $ContainerMetadata.id -VolumeInfo $volume -BackupPath $volumeBackupPath
            $containerBackup.volumes += $volumeBackup
            
            if ($volumeBackup.success) {
                $manifest.summary.total_volumes_backed_up++
            }
            
            $volumeIndex++
        }
        
        # Mark as successful if config backup succeeded
        if ($containerBackup.config.success) {
            $containerBackup.success = $true
            $manifest.summary.successful_backups++
            $manifest.summary.total_configs_backed_up++
        }
        else {
            $manifest.summary.failed_backups++
        }
        
        $containerBackup.backup_completed_at = Get-Date -Format "o"
        
        Write-Log "Completed backup for container: $($ContainerMetadata.name) (Success: $($containerBackup.success))" "INFO"
        
        return $containerBackup
    }
    catch {
        Write-Log "Error backing up container $($ContainerMetadata.name): $_" "ERROR"
        $manifest.summary.failed_backups++
        
        return @{
            container_id = $ContainerMetadata.id
            container_name = $ContainerMetadata.name
            image = $ContainerMetadata.image
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Test-BackupIntegrity {
    param(
        [Parameter(Mandatory=$true)]
        [array]$ContainerBackups
    )
    
    try {
        Write-Log "Verifying backup integrity..." "INFO"
        
        $allPassed = $true
        $failedVerifications = @()
        
        foreach ($containerBackup in $ContainerBackups) {
            if (-not $containerBackup.success) {
                continue
            }
            
            Write-Log "Verifying backup for: $($containerBackup.container_name)" "INFO"
            
            # Verify config checksum
            if ($containerBackup.config -and $containerBackup.config.checksum) {
                $currentChecksum = Get-DirectoryChecksum -DirectoryPath $containerBackup.config.backup_path
                
                if ($currentChecksum -ne $containerBackup.config.checksum) {
                    Write-Log "Config checksum mismatch for $($containerBackup.container_name)" "ERROR"
                    $allPassed = $false
                    $failedVerifications += @{
                        container = $containerBackup.container_name
                        type = "config"
                        expected = $containerBackup.config.checksum
                        actual = $currentChecksum
                    }
                }
            }
            
            # Verify volume checksums
            foreach ($volumeBackup in $containerBackup.volumes) {
                if ($volumeBackup.success -and $volumeBackup.checksum) {
                    $currentChecksum = Get-DirectoryChecksum -DirectoryPath $volumeBackup.backup_path
                    
                    if ($currentChecksum -ne $volumeBackup.checksum) {
                        Write-Log "Volume checksum mismatch for $($containerBackup.container_name) - $($volumeBackup.destination)" "ERROR"
                        $allPassed = $false
                        $failedVerifications += @{
                            container = $containerBackup.container_name
                            type = "volume"
                            destination = $volumeBackup.destination
                            expected = $volumeBackup.checksum
                            actual = $currentChecksum
                        }
                    }
                }
            }
        }
        
        return @{
            passed = $allPassed
            failed_verifications = $failedVerifications
        }
    }
    catch {
        Write-Log "Error during integrity verification: $_" "ERROR"
        return @{
            passed = $false
            failed_verifications = @(@{
                error = $_.Exception.Message
            })
        }
    }
}

# Main execution
try {
    Write-Log "Starting Docker data preservation and backup..." "INFO"
    
    # Check if inventory file exists
    if (-not (Test-Path $InventoryPath)) {
        throw "Inventory file not found: $InventoryPath. Please run Get-DockerInventory.ps1 first."
    }
    
    # Load inventory
    Write-Log "Loading inventory from: $InventoryPath" "INFO"
    $inventory = Get-Content $InventoryPath -Raw | ConvertFrom-Json
    
    if ($inventory.containers.Count -eq 0) {
        Write-Log "No containers found in inventory" "WARNING"
        throw "No containers to backup"
    }
    
    Write-Log "Found $($inventory.containers.Count) container(s) to backup" "INFO"
    
    # Create backup root directory
    if (-not (Test-Path $BackupRoot)) {
        Write-Log "Creating backup root directory: $BackupRoot" "INFO"
        New-Item -ItemType Directory -Path $BackupRoot -Force | Out-Null
    }
    
    # Backup each container
    $manifest.summary.total_containers = $inventory.containers.Count
    
    foreach ($container in $inventory.containers) {
        # Convert PSCustomObject to hashtable for easier manipulation
        $containerHash = @{}
        $container.PSObject.Properties | ForEach-Object { $containerHash[$_.Name] = $_.Value }
        
        $containerBackup = Backup-Container -ContainerMetadata $containerHash
        $manifest.containers += $containerBackup
        
        # Update total size
        foreach ($volumeBackup in $containerBackup.volumes) {
            if ($volumeBackup.size_bytes) {
                $manifest.summary.total_size_bytes += $volumeBackup.size_bytes
            }
        }
    }
    
    $manifest.backup_completed_at = Get-Date -Format "o"
    
    # Verify checksums if requested
    if ($VerifyChecksums) {
        Write-Log "Performing checksum verification..." "INFO"
        $verificationResult = Test-BackupIntegrity -ContainerBackups $manifest.containers
        
        $manifest.verification.checksums_verified = $true
        $manifest.verification.verification_passed = $verificationResult.passed
        $manifest.verification.failed_verifications = $verificationResult.failed_verifications
        
        if ($verificationResult.passed) {
            Write-Log "All checksums verified successfully" "INFO"
        }
        else {
            Write-Log "Checksum verification failed for $($verificationResult.failed_verifications.Count) item(s)" "ERROR"
        }
    }
    
    # Save backup manifest
    $manifestPath = Join-Path $BackupRoot "backup-manifest.json"
    Write-Log "Saving backup manifest to: $manifestPath" "INFO"
    $manifest | ConvertTo-Json -Depth 10 | Out-File -FilePath $manifestPath -Encoding UTF8
    
    # Display summary
    Write-Log "=== Backup Summary ===" "INFO"
    Write-Log "Total containers: $($manifest.summary.total_containers)" "INFO"
    Write-Log "Successful backups: $($manifest.summary.successful_backups)" "INFO"
    Write-Log "Failed backups: $($manifest.summary.failed_backups)" "INFO"
    Write-Log "Total volumes backed up: $($manifest.summary.total_volumes_backed_up)" "INFO"
    Write-Log "Total configs backed up: $($manifest.summary.total_configs_backed_up)" "INFO"
    Write-Log "Total size: $([math]::Round($manifest.summary.total_size_bytes / 1MB, 2)) MB" "INFO"
    Write-Log "Checksums verified: $($manifest.verification.checksums_verified)" "INFO"
    Write-Log "Verification passed: $($manifest.verification.verification_passed)" "INFO"
    
    # Return result
    if ($manifest.summary.failed_backups -gt 0) {
        Write-Log "Backup completed with errors" "WARNING"
        return @{
            success = $false
            manifest_path = $manifestPath
            summary = $manifest.summary
            verification = $manifest.verification
        }
    }
    elseif ($VerifyChecksums -and -not $manifest.verification.verification_passed) {
        Write-Log "Backup completed but checksum verification failed" "ERROR"
        return @{
            success = $false
            manifest_path = $manifestPath
            summary = $manifest.summary
            verification = $manifest.verification
        }
    }
    else {
        Write-Log "Backup completed successfully" "INFO"
        return @{
            success = $true
            manifest_path = $manifestPath
            summary = $manifest.summary
            verification = $manifest.verification
        }
    }
}
catch {
    Write-Log "Fatal error during backup: $_" "ERROR"
    Write-Log $_.ScriptStackTrace "ERROR"
    
    # Save partial manifest if possible
    try {
        $manifest.backup_completed_at = Get-Date -Format "o"
        $manifest.error = $_.Exception.Message
        $manifestPath = Join-Path $BackupRoot "backup-manifest-failed.json"
        $manifest | ConvertTo-Json -Depth 10 | Out-File -FilePath $manifestPath -Encoding UTF8
        Write-Log "Partial manifest saved to: $manifestPath" "INFO"
    }
    catch {
        Write-Log "Failed to save partial manifest: $_" "ERROR"
    }
    
    # Return error
    return @{
        success = $false
        error = $_.Exception.Message
        stack_trace = $_.ScriptStackTrace
    }
}
