# Remove-DockerArtifacts.ps1
# Docker Artifact Cleanup System
# Removes Docker images, networks, and volumes after data preservation
# Verifies complete cleanup with no remaining Docker processes

<#
.SYNOPSIS
    Removes all Docker artifacts after container termination and data preservation.

.DESCRIPTION
    Implements comprehensive Docker cleanup including image removal, network cleanup,
    and volume cleanup (only after data preservation is verified). Ensures no Docker
    artifacts remain and verifies no Docker processes are running.
    Integrates with migration state tracking for audit and rollback capability.

.PARAMETER InventoryPath
    Path to the inventory JSON file generated by Get-DockerInventory.ps1
    Default: C:\project\migration\inventory.json

.PARAMETER BackupManifestPath
    Path to the backup manifest JSON file to verify data preservation.
    Default: C:\project\migration\backups\backup-manifest.json

.PARAMETER StatePath
    Path to the migration state JSON file.
    Default: C:\project\migration\migration-state.json

.PARAMETER RemoveImages
    Remove Docker images used by containers.
    Default: $true

.PARAMETER RemoveNetworks
    Remove Docker networks created for containers.
    Default: $true

.PARAMETER RemoveVolumes
    Remove Docker volumes (only after data preservation verification).
    Default: $true

.PARAMETER VerifyCleanup
    Verify that no Docker artifacts remain after cleanup.
    Default: $true

.EXAMPLE
    .\Remove-DockerArtifacts.ps1
    Removes all Docker artifacts with default settings.

.EXAMPLE
    .\Remove-DockerArtifacts.ps1 -RemoveVolumes $false
    Removes images and networks but preserves volumes.

.EXAMPLE
    .\Remove-DockerArtifacts.ps1 -InventoryPath "C:\custom\inventory.json"
    Removes artifacts using custom inventory path.

.NOTES
    Validates: Requirements 1.4, 1.5
    Part of: Sentient Corp Native Architecture Migration
#>

[CmdletBinding()]
param(
    [Parameter(Mandatory=$false)]
    [string]$InventoryPath = $null,
    
    [Parameter(Mandatory=$false)]
    [string]$BackupManifestPath = $null,
    
    [Parameter(Mandatory=$false)]
    [string]$StatePath = $null,
    
    [Parameter(Mandatory=$false)]
    [bool]$RemoveImages = $true,
    
    [Parameter(Mandatory=$false)]
    [bool]$RemoveNetworks = $true,
    
    [Parameter(Mandatory=$false)]
    [bool]$RemoveVolumes = $true,
    
    [Parameter(Mandatory=$false)]
    [bool]$VerifyCleanup = $true
)

$ErrorActionPreference = "Stop"

# Robust path resolution
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
if (-not $scriptDir) { $scriptDir = "." }

if (-not $InventoryPath) { $InventoryPath = Join-Path $scriptDir "inventory.json" }
if (-not $BackupManifestPath) { $BackupManifestPath = Join-Path $scriptDir "backups\backup-manifest.json" }
if (-not $StatePath) { $StatePath = Join-Path $scriptDir "migration-state.json" }

# Import MigrationState functions
$migrationStateScript = Join-Path $PSScriptRoot "MigrationState.ps1"
if (Test-Path $migrationStateScript) {
    . $migrationStateScript
}
else {
    Write-Warning "MigrationState.ps1 not found. State tracking will be limited."
}

# Initialize cleanup report
$cleanupReport = @{
    started_at = Get-Date -Format "o"
    completed_at = $null
    inventory_source = $InventoryPath
    backup_manifest_source = $BackupManifestPath
    images = @{
        total = 0
        removed = 0
        failed = 0
        details = @()
    }
    networks = @{
        total = 0
        removed = 0
        failed = 0
        details = @()
    }
    volumes = @{
        total = 0
        removed = 0
        failed = 0
        details = @()
    }
    verification = @{
        performed = $false
        passed = $false
        remaining_artifacts = @()
    }
    data_preservation_verified = $false
}

function Write-Log {
    param([string]$Message, [string]$Level = "INFO")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    Write-Host "[$timestamp] [$Level] $Message"
}

function Test-DataPreservation {
    <#
    .SYNOPSIS
        Verifies that data has been preserved before allowing volume deletion.
    
    .PARAMETER BackupManifestPath
        Path to the backup manifest JSON file.
    
    .RETURNS
        $true if data preservation is verified, $false otherwise.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$BackupManifestPath
    )
    
    try {
        Write-Log "Verifying data preservation before volume cleanup..." "INFO"
        
        if (-not (Test-Path $BackupManifestPath)) {
            Write-Log "Backup manifest not found: $BackupManifestPath" "ERROR"
            return $false
        }
        
        $manifest = Get-Content $BackupManifestPath -Raw | ConvertFrom-Json
        
        # Check if backup completed successfully
        if ($manifest.backup_completed_at -eq $null) {
            Write-Log "Backup not completed" "ERROR"
            return $false
        }
        
        # Check if any backups failed
        if ($manifest.summary.failed_backups -gt 0) {
            Write-Log "Backup had $($manifest.summary.failed_backups) failure(s)" "ERROR"
            return $false
        }
        
        # Check if checksums were verified
        if ($manifest.verification.checksums_verified -and -not $manifest.verification.verification_passed) {
            Write-Log "Checksum verification failed" "ERROR"
            return $false
        }
        
        Write-Log "Data preservation verified successfully" "INFO"
        return $true
    }
    catch {
        Write-Log "Error verifying data preservation: $_" "ERROR"
        return $false
    }
}

function Remove-DockerImage {
    <#
    .SYNOPSIS
        Removes a Docker image.
    
    .PARAMETER ImageId
        The image ID to remove.
    
    .PARAMETER ImageName
        The image name (for logging).
    
    .RETURNS
        Hashtable with removal status and details.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$ImageId,
        
        [Parameter(Mandatory=$true)]
        [string]$ImageName
    )
    
    try {
        Write-Log "Removing Docker image: $ImageName" "INFO"
        
        $result = @{
            image_id = $ImageId
            image_name = $ImageName
            success = $false
            removed_at = $null
            error = $null
        }
        
        # Execute docker rmi
        Write-Log "Executing: docker rmi $ImageId" "INFO"
        $rmiOutput = docker rmi $ImageId 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-Log "Image $ImageName removed successfully" "INFO"
            $result.success = $true
            $result.removed_at = Get-Date -Format "o"
        }
        else {
            Write-Log "Failed to remove image $ImageName : $rmiOutput" "ERROR"
            $result.error = "Docker rmi failed: $rmiOutput"
        }
        
        return $result
    }
    catch {
        Write-Log "Exception removing image $ImageName : $_" "ERROR"
        return @{
            image_id = $ImageId
            image_name = $ImageName
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Remove-DockerNetwork {
    <#
    .SYNOPSIS
        Removes a Docker network.
    
    .PARAMETER NetworkId
        The network ID to remove.
    
    .PARAMETER NetworkName
        The network name (for logging).
    
    .RETURNS
        Hashtable with removal status and details.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$NetworkId,
        
        [Parameter(Mandatory=$true)]
        [string]$NetworkName
    )
    
    try {
        Write-Log "Removing Docker network: $NetworkName" "INFO"
        
        $result = @{
            network_id = $NetworkId
            network_name = $NetworkName
            success = $false
            removed_at = $null
            error = $null
        }
        
        # Skip default networks
        $defaultNetworks = @("bridge", "host", "none")
        if ($defaultNetworks -contains $NetworkName) {
            Write-Log "Skipping default network: $NetworkName" "INFO"
            $result.success = $true
            $result.removed_at = Get-Date -Format "o"
            $result.error = "Skipped (default network)"
            return $result
        }
        
        # Execute docker network rm
        Write-Log "Executing: docker network rm $NetworkId" "INFO"
        $rmOutput = docker network rm $NetworkId 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-Log "Network $NetworkName removed successfully" "INFO"
            $result.success = $true
            $result.removed_at = Get-Date -Format "o"
        }
        else {
            Write-Log "Failed to remove network $NetworkName : $rmOutput" "ERROR"
            $result.error = "Docker network rm failed: $rmOutput"
        }
        
        return $result
    }
    catch {
        Write-Log "Exception removing network $NetworkName : $_" "ERROR"
        return @{
            network_id = $NetworkId
            network_name = $NetworkName
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Remove-DockerVolume {
    <#
    .SYNOPSIS
        Removes a Docker volume.
    
    .PARAMETER VolumeName
        The volume name to remove.
    
    .RETURNS
        Hashtable with removal status and details.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$VolumeName
    )
    
    try {
        Write-Log "Removing Docker volume: $VolumeName" "INFO"
        
        $result = @{
            volume_name = $VolumeName
            success = $false
            removed_at = $null
            error = $null
        }
        
        # Execute docker volume rm
        Write-Log "Executing: docker volume rm $VolumeName" "INFO"
        $rmOutput = docker volume rm $VolumeName 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-Log "Volume $VolumeName removed successfully" "INFO"
            $result.success = $true
            $result.removed_at = Get-Date -Format "o"
        }
        else {
            Write-Log "Failed to remove volume $VolumeName : $rmOutput" "ERROR"
            $result.error = "Docker volume rm failed: $rmOutput"
        }
        
        return $result
    }
    catch {
        Write-Log "Exception removing volume $VolumeName : $_" "ERROR"
        return @{
            volume_name = $VolumeName
            success = $false
            error = $_.Exception.Message
        }
    }
}

function Test-DockerProcesses {
    <#
    .SYNOPSIS
        Verifies that no Docker processes are running.
    
    .RETURNS
        Hashtable with verification results.
    #>
    try {
        Write-Log "Checking for running Docker processes..." "INFO"
        
        $verification = @{
            docker_daemon_running = $false
            running_containers = @()
            remaining_images = @()
            remaining_networks = @()
            remaining_volumes = @()
            all_clean = $false
        }
        
        # Check if Docker daemon is accessible
        try {
            $null = docker version 2>&1
            $verification.docker_daemon_running = ($LASTEXITCODE -eq 0)
        }
        catch {
            $verification.docker_daemon_running = $false
        }
        
        if (-not $verification.docker_daemon_running) {
            Write-Log "Docker daemon is not running" "INFO"
            $verification.all_clean = $true
            return $verification
        }
        
        # Check for running containers
        try {
            $runningContainers = docker ps -q 2>&1
            if ($LASTEXITCODE -eq 0 -and $runningContainers) {
                $verification.running_containers = $runningContainers -split "`n" | Where-Object { $_ -ne "" }
                Write-Log "Found $($verification.running_containers.Count) running container(s)" "WARNING"
            }
        }
        catch {
            Write-Log "Error checking running containers: $_" "WARNING"
        }
        
        # Check for remaining images
        try {
            $images = docker images -q 2>&1
            if ($LASTEXITCODE -eq 0 -and $images) {
                $verification.remaining_images = $images -split "`n" | Where-Object { $_ -ne "" }
                Write-Log "Found $($verification.remaining_images.Count) remaining image(s)" "INFO"
            }
        }
        catch {
            Write-Log "Error checking images: $_" "WARNING"
        }
        
        # Check for remaining networks (excluding defaults)
        try {
            $networks = docker network ls --format "{{.Name}}" 2>&1
            if ($LASTEXITCODE -eq 0 -and $networks) {
                $defaultNetworks = @("bridge", "host", "none")
                $verification.remaining_networks = ($networks -split "`n" | Where-Object { $_ -ne "" -and $defaultNetworks -notcontains $_ })
                if ($verification.remaining_networks.Count -gt 0) {
                    Write-Log "Found $($verification.remaining_networks.Count) remaining network(s)" "INFO"
                }
            }
        }
        catch {
            Write-Log "Error checking networks: $_" "WARNING"
        }
        
        # Check for remaining volumes
        try {
            $volumes = docker volume ls -q 2>&1
            if ($LASTEXITCODE -eq 0 -and $volumes) {
                $verification.remaining_volumes = $volumes -split "`n" | Where-Object { $_ -ne "" }
                Write-Log "Found $($verification.remaining_volumes.Count) remaining volume(s)" "INFO"
            }
        }
        catch {
            Write-Log "Error checking volumes: $_" "WARNING"
        }
        
        # Determine if all clean
        $verification.all_clean = (
            $verification.running_containers.Count -eq 0 -and
            $verification.remaining_images.Count -eq 0 -and
            $verification.remaining_networks.Count -eq 0 -and
            $verification.remaining_volumes.Count -eq 0
        )
        
        if ($verification.all_clean) {
            Write-Log "Verification passed: No Docker artifacts remain" "INFO"
        }
        else {
            Write-Log "Verification incomplete: Some Docker artifacts remain" "WARNING"
        }
        
        return $verification
    }
    catch {
        Write-Log "Error during Docker process verification: $_" "ERROR"
        return @{
            docker_daemon_running = $false
            all_clean = $false
            error = $_.Exception.Message
        }
    }
}

# Main execution
try {
    Write-Log "Starting Docker artifact cleanup..." "INFO"
    
    # Check if inventory file exists
    if (-not (Test-Path $InventoryPath)) {
        throw "Inventory file not found: $InventoryPath. Please run Get-DockerInventory.ps1 first."
    }
    
    # Load inventory
    Write-Log "Loading inventory from: $InventoryPath" "INFO"
    $inventory = Get-Content $InventoryPath -Raw | ConvertFrom-Json
    
    if ($inventory.containers.Count -eq 0) {
        Write-Log "No containers found in inventory" "WARNING"
    }
    
    # Verify data preservation before proceeding with volume cleanup
    if ($RemoveVolumes) {
        Write-Log "Verifying data preservation before volume cleanup..." "INFO"
        $cleanupReport.data_preservation_verified = Test-DataPreservation -BackupManifestPath $BackupManifestPath
        
        if (-not $cleanupReport.data_preservation_verified) {
            Write-Log "Data preservation not verified. Skipping volume cleanup for safety." "WARNING"
            $RemoveVolumes = $false
        }
    }
    
    # Remove Docker images
    if ($RemoveImages) {
        Write-Log "=== Removing Docker Images ===" "INFO"
        
        # Collect unique images from inventory
        $imagesToRemove = @{}
        foreach ($container in $inventory.containers) {
            if ($container.image -and $container.image_id) {
                $imagesToRemove[$container.image_id] = $container.image
            }
        }
        
        $cleanupReport.images.total = $imagesToRemove.Count
        Write-Log "Found $($imagesToRemove.Count) unique image(s) to remove" "INFO"
        
        foreach ($imageId in $imagesToRemove.Keys) {
            $imageName = $imagesToRemove[$imageId]
            $imageResult = Remove-DockerImage -ImageId $imageId -ImageName $imageName
            $cleanupReport.images.details += $imageResult
            
            if ($imageResult.success) {
                $cleanupReport.images.removed++
            }
            else {
                $cleanupReport.images.failed++
            }
        }
        
        Write-Log "Images removed: $($cleanupReport.images.removed)/$($cleanupReport.images.total)" "INFO"
    }
    
    # Remove Docker networks
    if ($RemoveNetworks) {
        Write-Log "=== Removing Docker Networks ===" "INFO"
        
        # Collect unique networks from inventory
        $networksToRemove = @{}
        foreach ($container in $inventory.containers) {
            if ($container.networks) {
                foreach ($network in $container.networks) {
                    if ($network.id -and $network.name) {
                        $networksToRemove[$network.id] = $network.name
                    }
                }
            }
        }
        
        $cleanupReport.networks.total = $networksToRemove.Count
        Write-Log "Found $($networksToRemove.Count) unique network(s) to remove" "INFO"
        
        foreach ($networkId in $networksToRemove.Keys) {
            $networkName = $networksToRemove[$networkId]
            $networkResult = Remove-DockerNetwork -NetworkId $networkId -NetworkName $networkName
            $cleanupReport.networks.details += $networkResult
            
            if ($networkResult.success) {
                $cleanupReport.networks.removed++
            }
            else {
                $cleanupReport.networks.failed++
            }
        }
        
        Write-Log "Networks removed: $($cleanupReport.networks.removed)/$($cleanupReport.networks.total)" "INFO"
    }
    
    # Remove Docker volumes
    if ($RemoveVolumes) {
        Write-Log "=== Removing Docker Volumes ===" "INFO"
        
        # Collect unique volumes from inventory
        $volumesToRemove = @{}
        foreach ($container in $inventory.containers) {
            if ($container.volumes) {
                foreach ($volume in $container.volumes) {
                    if ($volume.type -eq "volume" -and $volume.source) {
                        $volumesToRemove[$volume.source] = $true
                    }
                }
            }
        }
        
        $cleanupReport.volumes.total = $volumesToRemove.Count
        Write-Log "Found $($volumesToRemove.Count) unique volume(s) to remove" "INFO"
        
        foreach ($volumeName in $volumesToRemove.Keys) {
            $volumeResult = Remove-DockerVolume -VolumeName $volumeName
            $cleanupReport.volumes.details += $volumeResult
            
            if ($volumeResult.success) {
                $cleanupReport.volumes.removed++
            }
            else {
                $cleanupReport.volumes.failed++
            }
        }
        
        Write-Log "Volumes removed: $($cleanupReport.volumes.removed)/$($cleanupReport.volumes.total)" "INFO"
    }
    
    $cleanupReport.completed_at = Get-Date -Format "o"
    
    # Verify cleanup if requested
    if ($VerifyCleanup) {
        Write-Log "=== Verifying Docker Cleanup ===" "INFO"
        
        $verification = Test-DockerProcesses
        $cleanupReport.verification.performed = $true
        $cleanupReport.verification.passed = $verification.all_clean
        $cleanupReport.verification.remaining_artifacts = @{
            running_containers = $verification.running_containers
            remaining_images = $verification.remaining_images
            remaining_networks = $verification.remaining_networks
            remaining_volumes = $verification.remaining_volumes
        }
    }
    
    # Save cleanup report
    $reportDir = Split-Path -Parent $InventoryPath
    $reportPath = Join-Path $reportDir "docker-cleanup-report.json"
    Write-Log "Saving cleanup report to: $reportPath" "INFO"
    $cleanupReport | ConvertTo-Json -Depth 10 | Out-File -FilePath $reportPath -Encoding UTF8
    
    # Display summary
    Write-Log "=== Cleanup Summary ===" "INFO"
    Write-Log "Images: $($cleanupReport.images.removed)/$($cleanupReport.images.total) removed, $($cleanupReport.images.failed) failed" "INFO"
    Write-Log "Networks: $($cleanupReport.networks.removed)/$($cleanupReport.networks.total) removed, $($cleanupReport.networks.failed) failed" "INFO"
    Write-Log "Volumes: $($cleanupReport.volumes.removed)/$($cleanupReport.volumes.total) removed, $($cleanupReport.volumes.failed) failed" "INFO"
    Write-Log "Data preservation verified: $($cleanupReport.data_preservation_verified)" "INFO"
    Write-Log "Cleanup verification passed: $($cleanupReport.verification.passed)" "INFO"
    
    # Determine overall success
    $overallSuccess = (
        $cleanupReport.images.failed -eq 0 -and
        $cleanupReport.networks.failed -eq 0 -and
        $cleanupReport.volumes.failed -eq 0 -and
        $cleanupReport.verification.passed
    )
    
    if ($overallSuccess) {
        Write-Log "Docker artifact cleanup completed successfully" "INFO"
        return @{
            success = $true
            report_path = $reportPath
            summary = @{
                images = $cleanupReport.images
                networks = $cleanupReport.networks
                volumes = $cleanupReport.volumes
            }
            verification = $cleanupReport.verification
        }
    }
    else {
        Write-Log "Docker artifact cleanup completed with issues" "WARNING"
        return @{
            success = $false
            report_path = $reportPath
            summary = @{
                images = $cleanupReport.images
                networks = $cleanupReport.networks
                volumes = $cleanupReport.volumes
            }
            verification = $cleanupReport.verification
        }
    }
}
catch {
    Write-Log "Fatal error during Docker artifact cleanup: $_" "ERROR"
    Write-Log $_.ScriptStackTrace "ERROR"
    
    # Update migration state with error
    if (Get-Command -Name Set-MigrationError -ErrorAction SilentlyContinue) {
        try {
            Set-MigrationError -StatePath $StatePath -ErrorMessage "Docker cleanup failed: $($_.Exception.Message)"
        }
        catch {
            Write-Log "Could not update migration state with error: $_" "WARNING"
        }
    }
    
    # Save partial report if possible
    try {
        $cleanupReport.completed_at = Get-Date -Format "o"
        $cleanupReport.error = $_.Exception.Message
        $reportDir = Split-Path -Parent $InventoryPath
        $reportPath = Join-Path $reportDir "docker-cleanup-report-failed.json"
        $cleanupReport | ConvertTo-Json -Depth 10 | Out-File -FilePath $reportPath -Encoding UTF8
        Write-Log "Partial report saved to: $reportPath" "INFO"
    }
    catch {
        Write-Log "Failed to save partial report: $_" "ERROR"
    }
    
    # Return error
    return @{
        success = $false
        error = $_.Exception.Message
        stack_trace = $_.ScriptStackTrace
    }
}
