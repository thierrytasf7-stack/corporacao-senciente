/**
 * PRD Template v2.0 Test Suite
 * Tests for Story 3.7 - Template PRD v2.0
 *
 * Test IDs:
 * - PRD-01: Generate PRD with required fields only
 * - PRD-02: Generate PRD with UI/UX section
 * - PRD-03: Generate PRD with Brownfield section
 * - PRD-04: Validation fails on missing required field
 * - PRD-05: Variable elicitation prompts correctly
 * - PRD-06: Validation error messages are clear and actionable
 * - PRD-07: Conditional validation (UI/UX fields when includeUIUX=true)
 * - PRD-08: Conditional validation (Brownfield fields when isBrownfield=true)
 */

'use strict';

const path = require('path');

// Mock inquirer for non-interactive tests
jest.mock('inquirer', () => ({
  prompt: jest.fn().mockResolvedValue({}),
}));

const {
  TemplateEngine,
  TemplateLoader,
  TemplateValidator,
} = require('../../.aios-core/product/templates/engine');

describe('PRD Template v2.0 (Story 3.7)', () => {
  const baseDir = path.join(__dirname, '..', '..');
  const templatesDir = path.join(baseDir, '.aios-core', 'product', 'templates');
  const schemasDir = path.join(templatesDir, 'engine', 'schemas');

  let engine;
  let validator;

  // Complete valid context for PRD generation
  const validContext = {
    projectName: 'Test Project',
    productName: 'Test Product',
    version: '1.0.0',
    author: 'Test Author',
    problemStatement: 'This is a detailed problem statement that describes what problem we are solving for users. It needs to be at least 50 characters long.',
    goals: [
      'Goal 1: Improve user experience',
      'Goal 2: Increase efficiency',
    ],
    userStories: [
      {
        title: 'User Registration',
        actor: 'New User',
        action: 'register for an account',
        benefit: 'I can access the system features',
        criteria: ['Email must be valid', 'Password must be at least 8 characters'],
      },
    ],
    functionalRequirements: [
      {
        title: 'User Authentication',
        description: 'System must support email/password authentication',
        priority: 'P0',
      },
    ],
    nonFunctionalRequirements: [
      {
        category: 'Performance',
        requirement: 'Page load time must be under 2 seconds',
      },
    ],
    successMetrics: [
      {
        metric: 'User Adoption',
        target: '1000 users in 3 months',
        method: 'Analytics tracking',
      },
    ],
    milestones: [
      {
        name: 'MVP Release',
        date: '2025-03-01',
      },
    ],
    risks: [
      {
        risk: 'Technical complexity',
        impact: 'High',
        probability: 'Medium',
        mitigation: 'Early prototyping and POC',
      },
    ],
    includeUIUX: false,
    isBrownfield: false,
  };

  beforeEach(() => {
    engine = new TemplateEngine({
      baseDir,
      templatesDir,
      schemasDir,
      interactive: false,
    });
    validator = new TemplateValidator({ schemasDir });
    jest.clearAllMocks();
  });

  describe('PRD-01: Generate PRD with required fields only', () => {
    test('should generate complete PRD with all required sections', async () => {
      const result = await engine.generate('prd-v2', validContext);

      expect(result.content).toBeDefined();
      expect(result.content).toContain('# Product Requirements Document - Test Project');
      expect(result.content).toContain('**Product:** Test Product');
      expect(result.content).toContain('**Version:** 1.0.0');
      expect(result.content).toContain('**Author:** Test Author');
      expect(result.content).toContain('## 1. Problem Statement');
      expect(result.content).toContain('## 2. Goals & Objectives');
      expect(result.content).toContain('## 3. User Stories');
      expect(result.content).toContain('## 4. Functional Requirements');
      expect(result.content).toContain('## 5. Non-Functional Requirements');
      expect(result.content).toContain('Success Metrics');
      expect(result.content).toContain('Timeline & Milestones');
      expect(result.content).toContain('Risks & Mitigations');
      expect(result.content).toContain('**Generated by:** AIOS Template Engine v2.0');
    });

    test('should not include UI/UX section when includeUIUX is false', async () => {
      const result = await engine.generate('prd-v2', validContext);

      expect(result.content).not.toContain('UI/UX Requirements');
      expect(result.content).not.toContain('User Flows');
      expect(result.content).not.toContain('Design Considerations');
    });

    test('should not include Brownfield section when isBrownfield is false', async () => {
      const result = await engine.generate('prd-v2', validContext);

      expect(result.content).not.toContain('Brownfield Considerations');
      expect(result.content).not.toContain('Existing System Analysis');
      expect(result.content).not.toContain('Integration Points');
      expect(result.content).not.toContain('Migration Strategy');
    });
  });

  describe('PRD-02: Generate PRD with UI/UX section', () => {
    test('should include UI/UX section when includeUIUX is true', async () => {
      const contextWithUIUX = {
        ...validContext,
        includeUIUX: true,
        userFlows: [
          'User opens app → Login screen → Dashboard',
          'Dashboard → Create item → Review → Submit',
        ],
        designConsiderations: 'The design should follow Material Design guidelines with a focus on accessibility and mobile-first approach.',
      };

      const result = await engine.generate('prd-v2', contextWithUIUX);

      expect(result.content).toContain('## 6. UI/UX Requirements');
      expect(result.content).toContain('### User Flows');
      expect(result.content).toContain('User opens app → Login screen → Dashboard');
      expect(result.content).toContain('### Design Considerations');
      expect(result.content).toContain('Material Design guidelines');
    });

    test('should render all user flows as list items', async () => {
      const contextWithUIUX = {
        ...validContext,
        includeUIUX: true,
        userFlows: ['Flow 1', 'Flow 2', 'Flow 3'],
        designConsiderations: 'Design considerations text for the product interface.',
      };

      const result = await engine.generate('prd-v2', contextWithUIUX);

      expect(result.content).toContain('- Flow 1');
      expect(result.content).toContain('- Flow 2');
      expect(result.content).toContain('- Flow 3');
    });
  });

  describe('PRD-03: Generate PRD with Brownfield section', () => {
    test('should include Brownfield section when isBrownfield is true', async () => {
      const contextWithBrownfield = {
        ...validContext,
        isBrownfield: true,
        existingSystemAnalysis: 'The existing system is a monolithic application built with Java and PostgreSQL. It handles 10,000 requests per day.',
        integrationPoints: [
          'User authentication API',
          'Payment processing service',
          'Legacy database',
        ],
        migrationStrategy: 'We will use a strangler fig pattern to gradually migrate functionality from the monolith to microservices.',
      };

      const result = await engine.generate('prd-v2', contextWithBrownfield);

      expect(result.content).toContain('Brownfield Considerations');
      expect(result.content).toContain('### Existing System Analysis');
      expect(result.content).toContain('monolithic application built with Java');
      expect(result.content).toContain('### Integration Points');
      expect(result.content).toContain('- User authentication API');
      expect(result.content).toContain('- Payment processing service');
      expect(result.content).toContain('### Migration Strategy');
      expect(result.content).toContain('strangler fig pattern');
    });

    test('should render all integration points as list items', async () => {
      const contextWithBrownfield = {
        ...validContext,
        isBrownfield: true,
        existingSystemAnalysis: 'Existing system analysis text that must be at least 50 characters long.',
        integrationPoints: ['API 1', 'API 2', 'Database'],
        migrationStrategy: 'Migration strategy text that must be at least 50 characters long for validation.',
      };

      const result = await engine.generate('prd-v2', contextWithBrownfield);

      expect(result.content).toContain('- API 1');
      expect(result.content).toContain('- API 2');
      expect(result.content).toContain('- Database');
    });
  });

  describe('PRD-04: Validation fails on missing required field', () => {
    test('should fail validation when projectName is missing', async () => {
      const incompleteContext = { ...validContext };
      delete incompleteContext.projectName;

      const result = await validator.validate(incompleteContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('projectName'))).toBe(true);
    });

    test('should fail validation when problemStatement is too short', async () => {
      const invalidContext = {
        ...validContext,
        problemStatement: 'Too short',
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('problemStatement'))).toBe(true);
    });

    test('should fail validation when goals array is empty', async () => {
      const invalidContext = {
        ...validContext,
        goals: [],
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('goals'))).toBe(true);
    });

    test('should fail validation when risk has invalid impact value', async () => {
      const invalidContext = {
        ...validContext,
        risks: [{
          risk: 'Some risk',
          impact: 'Invalid',
          probability: 'High',
          mitigation: 'Some mitigation',
        }],
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('impact') || e.includes('allowed'))).toBe(true);
    });
  });

  describe('PRD-05: Variable elicitation prompts correctly', () => {
    test('should load template with all variable definitions', async () => {
      const loader = new TemplateLoader({ templatesDir });
      const template = await loader.load('prd-v2');

      expect(template.variables).toBeDefined();
      expect(Array.isArray(template.variables)).toBe(true);

      // Check required variables
      const projectNameVar = template.variables.find(v => v.name === 'projectName');
      expect(projectNameVar).toBeDefined();
      expect(projectNameVar.required).toBe(true);
      expect(projectNameVar.prompt).toBe('Nome do projeto:');

      const problemStatementVar = template.variables.find(v => v.name === 'problemStatement');
      expect(problemStatementVar).toBeDefined();
      expect(problemStatementVar.type).toBe('text');
    });

    test('should have prompts for all required variables', async () => {
      const loader = new TemplateLoader({ templatesDir });
      const template = await loader.load('prd-v2');

      const requiredVars = template.variables.filter(v => v.required === true);

      requiredVars.forEach(v => {
        expect(v.prompt).toBeDefined();
        expect(v.prompt.length).toBeGreaterThan(0);
      });
    });

    test('should have conditional variables for UI/UX and Brownfield', async () => {
      const loader = new TemplateLoader({ templatesDir });
      const template = await loader.load('prd-v2');

      const userFlowsVar = template.variables.find(v => v.name === 'userFlows');
      expect(userFlowsVar).toBeDefined();
      expect(userFlowsVar.requiredIf).toBe('includeUIUX');

      const existingSystemVar = template.variables.find(v => v.name === 'existingSystemAnalysis');
      expect(existingSystemVar).toBeDefined();
      expect(existingSystemVar.requiredIf).toBe('isBrownfield');
    });
  });

  describe('PRD-06: Validation error messages are clear and actionable', () => {
    test('should provide clear error message for missing required field', async () => {
      const incompleteContext = { ...validContext };
      delete incompleteContext.author;

      const result = await validator.validate(incompleteContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      // Error should mention the missing field by name
      expect(result.errors.some(e => e.includes('author') || e.includes('missing'))).toBe(true);
    });

    test('should provide clear error message for invalid enum value', async () => {
      const invalidContext = {
        ...validContext,
        functionalRequirements: [{
          title: 'Test',
          description: 'Test description',
          priority: 'P5', // Invalid - should be P0-P3
        }],
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      // Error should indicate allowed values
      expect(result.errors.some(e => e.includes('priority') || e.includes('allowed') || e.includes('P0'))).toBe(true);
    });

    test('should provide clear error message for minimum length violation', async () => {
      const invalidContext = {
        ...validContext,
        problemStatement: 'Short', // Less than 50 characters
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('problemStatement'))).toBe(true);
    });
  });

  describe('PRD-07: Conditional validation (UI/UX fields when includeUIUX=true)', () => {
    test('should fail validation when includeUIUX=true but userFlows is missing', async () => {
      const invalidContext = {
        ...validContext,
        includeUIUX: true,
        designConsiderations: 'Design considerations text for the product interface.',
        // userFlows is missing
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('userFlows'))).toBe(true);
    });

    test('should fail validation when includeUIUX=true but designConsiderations is missing', async () => {
      const invalidContext = {
        ...validContext,
        includeUIUX: true,
        userFlows: ['Flow 1', 'Flow 2'],
        // designConsiderations is missing
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('designConsiderations'))).toBe(true);
    });

    test('should pass validation when includeUIUX=true and all UI/UX fields are provided', async () => {
      const validUIUXContext = {
        ...validContext,
        includeUIUX: true,
        userFlows: ['User opens app → Login screen → Dashboard'],
        designConsiderations: 'Design considerations text for the product interface.',
      };

      const result = await validator.validate(validUIUXContext, 'prd-v2');

      expect(result.isValid).toBe(true);
    });

    test('should pass validation when includeUIUX=false even without UI/UX fields', async () => {
      const result = await validator.validate(validContext, 'prd-v2');

      expect(result.isValid).toBe(true);
    });
  });

  describe('PRD-08: Conditional validation (Brownfield fields when isBrownfield=true)', () => {
    test('should fail validation when isBrownfield=true but existingSystemAnalysis is missing', async () => {
      const invalidContext = {
        ...validContext,
        isBrownfield: true,
        integrationPoints: ['API 1'],
        migrationStrategy: 'Migration strategy text that must be at least 50 characters long for validation.',
        // existingSystemAnalysis is missing
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('existingSystemAnalysis'))).toBe(true);
    });

    test('should fail validation when isBrownfield=true but integrationPoints is missing', async () => {
      const invalidContext = {
        ...validContext,
        isBrownfield: true,
        existingSystemAnalysis: 'Existing system analysis text that must be at least 50 characters long.',
        migrationStrategy: 'Migration strategy text that must be at least 50 characters long for validation.',
        // integrationPoints is missing
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('integrationPoints'))).toBe(true);
    });

    test('should fail validation when isBrownfield=true but migrationStrategy is missing', async () => {
      const invalidContext = {
        ...validContext,
        isBrownfield: true,
        existingSystemAnalysis: 'Existing system analysis text that must be at least 50 characters long.',
        integrationPoints: ['API 1'],
        // migrationStrategy is missing
      };

      const result = await validator.validate(invalidContext, 'prd-v2');

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.includes('migrationStrategy'))).toBe(true);
    });

    test('should pass validation when isBrownfield=true and all Brownfield fields are provided', async () => {
      const validBrownfieldContext = {
        ...validContext,
        isBrownfield: true,
        existingSystemAnalysis: 'Existing system analysis text that must be at least 50 characters long.',
        integrationPoints: ['API 1', 'API 2'],
        migrationStrategy: 'Migration strategy text that must be at least 50 characters long for validation.',
      };

      const result = await validator.validate(validBrownfieldContext, 'prd-v2');

      expect(result.isValid).toBe(true);
    });

    test('should pass validation when isBrownfield=false even without Brownfield fields', async () => {
      const result = await validator.validate(validContext, 'prd-v2');

      expect(result.isValid).toBe(true);
    });
  });

  describe('Combined scenarios', () => {
    test('should generate PRD with both UI/UX and Brownfield sections', async () => {
      const fullContext = {
        ...validContext,
        includeUIUX: true,
        userFlows: ['Flow 1', 'Flow 2'],
        designConsiderations: 'Design considerations text for the product interface.',
        isBrownfield: true,
        existingSystemAnalysis: 'Existing system analysis text that must be at least 50 characters long.',
        integrationPoints: ['API 1', 'API 2'],
        migrationStrategy: 'Migration strategy text that must be at least 50 characters long for validation.',
      };

      const result = await engine.generate('prd-v2', fullContext);

      expect(result.content).toContain('UI/UX Requirements');
      expect(result.content).toContain('Brownfield Considerations');
    });

    test('should validate PRD with both UI/UX and Brownfield enabled', async () => {
      const fullContext = {
        ...validContext,
        includeUIUX: true,
        userFlows: ['Flow 1', 'Flow 2'],
        designConsiderations: 'Design considerations text for the product interface.',
        isBrownfield: true,
        existingSystemAnalysis: 'Existing system analysis text that must be at least 50 characters long.',
        integrationPoints: ['API 1', 'API 2'],
        migrationStrategy: 'Migration strategy text that must be at least 50 characters long for validation.',
      };

      const result = await validator.validate(fullContext, 'prd-v2');

      expect(result.isValid).toBe(true);
    });
  });
});
